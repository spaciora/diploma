<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no">
	<title>Виртуальная экскурсия по ККМБ</title>
	<style>
		body {
			margin: 0px;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%
		}
	</style>
	<link rel="shortcut icon" href="img/logo.jpg" type="image/x-icon">
</head>

<body>

	<div id='container'></div>

	<script type="text/javascript" src="libs/three.js"></script>
	<script type="text/javascript" src="libs/jquery-3.3.1.js"></script>
	<script type="text/javascript" src="libs/stats.min.js"></script>
	<script type="text/javascript" src="data.js"></script>
	<script type="text/javascript" src="libs/OrbitControls.js"></script>
	<script type="text/javascript" src="libs/OrbitControls.js"></script>
	<script type="text/javascript" src="libs/THREEx.FullScreen.js"></script>
	<script type="text/javascript" src="libs/WebGL.js"></script>
	<script type="text/javascript" src="libs/iziModal.js"></script>
	<script type="text/javascript" src="libs/OBJLoader.js"></script>
	<script type="text/javascript" src="libs/jsfile.js"></script>
	<link rel="stylesheet" href="libs/iziModal.css" type="text/css" />

	<script>
		var otherScene, otherCamera, raycaster, otherINTERSECTED;
		var mouse = new THREE.Vector2(0, 0), INTERSECTED;
		var CSSRENDERER;
		var PageLoaded = false;

		var points = [];

		var spriteGeometry, spriteMaterial, spriteMesh;
		var spriteTexture;

		var mapClickEvent = new Event('mapClicked');

		if (WEBGL.isWebGLAvailable() === false) {
			document.body.appendChild(WEBGL.getWebGLErrorMessage());
		}
  
		init();
		animate();

		function init() {
			var container;

			container = document.getElementById("container");
			document.body.appendChild(container);

			raycaster = new THREE.Raycaster();

			otherScene = new THREE.Scene();
			otherScene.background = new THREE.Color(0xffffff);
			otherCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
			otherCamera.position.z = 7;
			//otherCamera.position.y = 1.8;

			if (window.innerHeight > window.innerWidth) {
				//otherCamera.position.z = 2;
				otherCamera.position.y = 2.5;
			}

			spriteGeometry = new THREE.PlaneGeometry(10, 3.4, 1, 1);
			spriteTexture = new THREE.TextureLoader().load("img/map1.png");
			spriteMaterial = new THREE.MeshBasicMaterial({ map: spriteTexture, transparent: true });
			spriteMesh = new THREE.Mesh(spriteGeometry, spriteMaterial);
			spriteMesh.rotation = 0.1 * Math.PI;
			spriteMesh.scale.y = -1;
			//spriteMesh.scale.x = -1;
			otherScene.add(spriteMesh);

			mapPoints.forEach(function (item, i, mapPoint) {
				spriteTexture = new THREE.TextureLoader().load("img/icons/link.png");
				spriteGeometry = new THREE.PlaneGeometry(0.5, 0.5, 1, 1);
				spriteMaterial = new THREE.MeshBasicMaterial({ map: spriteTexture, transparent: true });
				spriteMesh = new THREE.Mesh(spriteGeometry, spriteMaterial);
				spriteMesh.position.x = mapPoint[i].coords.x;
				spriteMesh.position.y = mapPoint[i].coords.y;
				spriteMesh.scale.y = -1;
				spriteMesh.userData = { name: mapPoint[i].name };
				//console.log(spriteMesh.userData);
				otherScene.add(spriteMesh);
				points.push(spriteMesh);
			});


			////////Блок инициализации рендереров/////////
			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.autoClear = false;
			container.appendChild(renderer.domElement);
			//////////////////////////////////////////////

			document.addEventListener('mousedown', onPointerStart, false);
			document.addEventListener('mousemove', onPointerMove, false);
			document.addEventListener('wheel', onDocumentMouseWheel, false);
			document.addEventListener('touchstart', onPointerStartTouch, false);
			container.addEventListener('touchend', onDocumentTouchEnd, false);
			window.addEventListener('resize', onWindowResize, false);

			window.onload = function() {
				PageLoaded = true;
				console.log( 'Документ и все ресурсы загружены' );
			  };
			  
		}	 
		function mapClick(object) {
			switch (object.userData.type) {
				case "Plus":
					var fov = camera.fov + (-100) * 0.03;
					camera.fov = THREE.Math.clamp(fov, 10, 75);
					camera.updateProjectionMatrix();
					break;
				case "Minus":
					var fov = camera.fov + 100 * 0.03;
					camera.fov = THREE.Math.clamp(fov, 10, 75);
					camera.updateProjectionMatrix();
					break;
				case "Left":
					CONTROLS.rotateLeft(-0.05);
					break;
				case "Right":
					CONTROLS.rotateLeft(0.05);
					break;
				case "Up":
					CONTROLS.rotateUp(0.05);
					break;
				case "Down":
					CONTROLS.rotateUp(-0.05);
					break;
				case "FullScreen":
					if (THREEx.FullScreen.activated()) {
						THREEx.FullScreen.cancel();
					} else {
						THREEx.FullScreen.request();
					}
					break;
			}
		}

		function onPointerStart(event) {

			event.preventDefault();

			raycaster.setFromCamera(mouse, otherCamera);
			intersects = raycaster.intersectObjects(points);
			if (intersects.length > 0) {
				//nextView = intersects[0].object.userData.name;
				//console.log(nextView);

				document.dispatchEvent(mapClickEvent);
				
				//навесить событие, обработка которого в tour.html
				//configuringView();
				//alert("point clicked");
				//mapClick();
			}
		}

		function onPointerStartTouch(event) {
			event.preventDefault();

			mouse.x = (event.touches[0].pageX / window.innerWidth) * 2 - 1;
			mouse.y = - (event.touches[0].pageY / window.innerHeight) * 2 + 1;

			onPointerStart(event);
		}

		function onDocumentTouchEnd(event) {
			upEventHandler(event);
		}

		function onPointerMove(event) {

			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

			raycaster.setFromCamera(mouse, otherCamera);
			intersects = raycaster.intersectObjects(points);
			if (intersects.length > 0) {
				if (otherINTERSECTED != intersects[0].object) {
					if (otherINTERSECTED) otherINTERSECTED.material.color.setHex(otherINTERSECTED.currentHex);

					otherINTERSECTED = intersects[0].object;
					otherINTERSECTED.currentHex = otherINTERSECTED.material.color.getHex();
					otherINTERSECTED.material.color.setHex(0xee5f00);
				}
			} else {
				if (otherINTERSECTED) otherINTERSECTED.material.color.setHex(otherINTERSECTED.currentHex);
				otherINTERSECTED = null;
			}
		}

		function onDocumentMouseWheel(event) {

			var fov = camera.fov + event.deltaY * 0.03;
			camera.fov = THREE.Math.clamp(fov, 10, 75);
			camera.updateProjectionMatrix();

		}

		function animate() {

			requestAnimationFrame(animate);
			render();

		}

		function render() {

			renderer.clear();
			renderer.clearDepth();
			renderer.render(otherScene, otherCamera);
		}

		function onWindowResize() {
			renderer.setSize(window.innerWidth, window.innerHeight);

			otherCamera.aspect = window.innerWidth / window.innerHeight;
			otherCamera.updateProjectionMatrix();
		}

	</script>

</body>

</html>